
IMU_Headtracker.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  0000074c  000007e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000074c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001c  00800104  00800104  000007e4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000007e4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000814  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000a0  00000000  00000000  00000854  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000be9  00000000  00000000  000008f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000908  00000000  00000000  000014dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000007b3  00000000  00000000  00001de5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000210  00000000  00000000  00002598  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000588  00000000  00000000  000027a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000006c8  00000000  00000000  00002d30  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000098  00000000  00000000  000033f8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 85 00 	jmp	0x10a	; 0x10a <__ctors_end>
   4:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
   8:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
   c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  10:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  14:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  18:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  1c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  20:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  24:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  28:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  2c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  30:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  34:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  38:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  3c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  40:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  44:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  48:	0c 94 8f 02 	jmp	0x51e	; 0x51e <__vector_18>
  4c:	0c 94 12 03 	jmp	0x624	; 0x624 <__vector_19>
  50:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__vector_20>
  54:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  58:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  5c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  60:	0c 94 01 02 	jmp	0x402	; 0x402 <__vector_24>
  64:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  68:	1c 02       	muls	r17, r28
  6a:	6e 02       	muls	r22, r30
  6c:	6e 02       	muls	r22, r30
  6e:	6e 02       	muls	r22, r30
  70:	6e 02       	muls	r22, r30
  72:	6e 02       	muls	r22, r30
  74:	6e 02       	muls	r22, r30
  76:	6e 02       	muls	r22, r30
  78:	1c 02       	muls	r17, r28
  7a:	6e 02       	muls	r22, r30
  7c:	6e 02       	muls	r22, r30
  7e:	6e 02       	muls	r22, r30
  80:	6e 02       	muls	r22, r30
  82:	6e 02       	muls	r22, r30
  84:	6e 02       	muls	r22, r30
  86:	6e 02       	muls	r22, r30
  88:	1e 02       	muls	r17, r30
  8a:	6e 02       	muls	r22, r30
  8c:	6e 02       	muls	r22, r30
  8e:	6e 02       	muls	r22, r30
  90:	6e 02       	muls	r22, r30
  92:	6e 02       	muls	r22, r30
  94:	6e 02       	muls	r22, r30
  96:	6e 02       	muls	r22, r30
  98:	6e 02       	muls	r22, r30
  9a:	6e 02       	muls	r22, r30
  9c:	6e 02       	muls	r22, r30
  9e:	6e 02       	muls	r22, r30
  a0:	6e 02       	muls	r22, r30
  a2:	6e 02       	muls	r22, r30
  a4:	6e 02       	muls	r22, r30
  a6:	6e 02       	muls	r22, r30
  a8:	1e 02       	muls	r17, r30
  aa:	6e 02       	muls	r22, r30
  ac:	6e 02       	muls	r22, r30
  ae:	6e 02       	muls	r22, r30
  b0:	6e 02       	muls	r22, r30
  b2:	6e 02       	muls	r22, r30
  b4:	6e 02       	muls	r22, r30
  b6:	6e 02       	muls	r22, r30
  b8:	6e 02       	muls	r22, r30
  ba:	6e 02       	muls	r22, r30
  bc:	6e 02       	muls	r22, r30
  be:	6e 02       	muls	r22, r30
  c0:	6e 02       	muls	r22, r30
  c2:	6e 02       	muls	r22, r30
  c4:	6e 02       	muls	r22, r30
  c6:	6e 02       	muls	r22, r30
  c8:	6a 02       	muls	r22, r26
  ca:	6e 02       	muls	r22, r30
  cc:	6e 02       	muls	r22, r30
  ce:	6e 02       	muls	r22, r30
  d0:	6e 02       	muls	r22, r30
  d2:	6e 02       	muls	r22, r30
  d4:	6e 02       	muls	r22, r30
  d6:	6e 02       	muls	r22, r30
  d8:	47 02       	muls	r20, r23
  da:	6e 02       	muls	r22, r30
  dc:	6e 02       	muls	r22, r30
  de:	6e 02       	muls	r22, r30
  e0:	6e 02       	muls	r22, r30
  e2:	6e 02       	muls	r22, r30
  e4:	6e 02       	muls	r22, r30
  e6:	6e 02       	muls	r22, r30
  e8:	6e 02       	muls	r22, r30
  ea:	6e 02       	muls	r22, r30
  ec:	6e 02       	muls	r22, r30
  ee:	6e 02       	muls	r22, r30
  f0:	6e 02       	muls	r22, r30
  f2:	6e 02       	muls	r22, r30
  f4:	6e 02       	muls	r22, r30
  f6:	6e 02       	muls	r22, r30
  f8:	3b 02       	muls	r19, r27
  fa:	6e 02       	muls	r22, r30
  fc:	6e 02       	muls	r22, r30
  fe:	6e 02       	muls	r22, r30
 100:	6e 02       	muls	r22, r30
 102:	6e 02       	muls	r22, r30
 104:	6e 02       	muls	r22, r30
 106:	6e 02       	muls	r22, r30
 108:	59 02       	muls	r21, r25

0000010a <__ctors_end>:
 10a:	11 24       	eor	r1, r1
 10c:	1f be       	out	0x3f, r1	; 63
 10e:	cf ef       	ldi	r28, 0xFF	; 255
 110:	d8 e0       	ldi	r29, 0x08	; 8
 112:	de bf       	out	0x3e, r29	; 62
 114:	cd bf       	out	0x3d, r28	; 61

00000116 <__do_copy_data>:
 116:	11 e0       	ldi	r17, 0x01	; 1
 118:	a0 e0       	ldi	r26, 0x00	; 0
 11a:	b1 e0       	ldi	r27, 0x01	; 1
 11c:	ec e4       	ldi	r30, 0x4C	; 76
 11e:	f7 e0       	ldi	r31, 0x07	; 7
 120:	02 c0       	rjmp	.+4      	; 0x126 <__do_copy_data+0x10>
 122:	05 90       	lpm	r0, Z+
 124:	0d 92       	st	X+, r0
 126:	a4 30       	cpi	r26, 0x04	; 4
 128:	b1 07       	cpc	r27, r17
 12a:	d9 f7       	brne	.-10     	; 0x122 <__do_copy_data+0xc>

0000012c <__do_clear_bss>:
 12c:	21 e0       	ldi	r18, 0x01	; 1
 12e:	a4 e0       	ldi	r26, 0x04	; 4
 130:	b1 e0       	ldi	r27, 0x01	; 1
 132:	01 c0       	rjmp	.+2      	; 0x136 <.do_clear_bss_start>

00000134 <.do_clear_bss_loop>:
 134:	1d 92       	st	X+, r1

00000136 <.do_clear_bss_start>:
 136:	a0 32       	cpi	r26, 0x20	; 32
 138:	b2 07       	cpc	r27, r18
 13a:	e1 f7       	brne	.-8      	; 0x134 <.do_clear_bss_loop>
 13c:	0e 94 a2 01 	call	0x344	; 0x344 <main>
 140:	0c 94 a4 03 	jmp	0x748	; 0x748 <_exit>

00000144 <__bad_interrupt>:
 144:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000148 <_Z13set_gyro_biasPi>:
 148:	cf 93       	push	r28
 14a:	df 93       	push	r29
 14c:	cd b7       	in	r28, 0x3d	; 61
 14e:	de b7       	in	r29, 0x3e	; 62
 150:	28 97       	sbiw	r28, 0x08	; 8
 152:	0f b6       	in	r0, 0x3f	; 63
 154:	f8 94       	cli
 156:	de bf       	out	0x3e, r29	; 62
 158:	0f be       	out	0x3f, r0	; 63
 15a:	cd bf       	out	0x3d, r28	; 61
 15c:	fc 01       	movw	r30, r24
 15e:	40 81       	ld	r20, Z
 160:	51 81       	ldd	r21, Z+1	; 0x01
 162:	51 95       	neg	r21
 164:	41 95       	neg	r20
 166:	51 09       	sbc	r21, r1
 168:	51 83       	std	Z+1, r21	; 0x01
 16a:	40 83       	st	Z, r20
 16c:	22 81       	ldd	r18, Z+2	; 0x02
 16e:	33 81       	ldd	r19, Z+3	; 0x03
 170:	31 95       	neg	r19
 172:	21 95       	neg	r18
 174:	31 09       	sbc	r19, r1
 176:	33 83       	std	Z+3, r19	; 0x03
 178:	22 83       	std	Z+2, r18	; 0x02
 17a:	84 81       	ldd	r24, Z+4	; 0x04
 17c:	95 81       	ldd	r25, Z+5	; 0x05
 17e:	91 95       	neg	r25
 180:	81 95       	neg	r24
 182:	91 09       	sbc	r25, r1
 184:	95 83       	std	Z+5, r25	; 0x05
 186:	84 83       	std	Z+4, r24	; 0x04
 188:	51 81       	ldd	r21, Z+1	; 0x01
 18a:	33 81       	ldd	r19, Z+3	; 0x03
 18c:	95 81       	ldd	r25, Z+5	; 0x05
 18e:	60 ed       	ldi	r22, 0xD0	; 208
 190:	69 83       	std	Y+1, r22	; 0x01
 192:	63 e1       	ldi	r22, 0x13	; 19
 194:	6a 83       	std	Y+2, r22	; 0x02
 196:	5b 83       	std	Y+3, r21	; 0x03
 198:	4c 83       	std	Y+4, r20	; 0x04
 19a:	3d 83       	std	Y+5, r19	; 0x05
 19c:	2e 83       	std	Y+6, r18	; 0x06
 19e:	9f 83       	std	Y+7, r25	; 0x07
 1a0:	88 87       	std	Y+8, r24	; 0x08
 1a2:	68 e0       	ldi	r22, 0x08	; 8
 1a4:	ce 01       	movw	r24, r28
 1a6:	01 96       	adiw	r24, 0x01	; 1
 1a8:	0e 94 b4 01 	call	0x368	; 0x368 <TWI_Start_Transceiver_With_Data>
 1ac:	80 e0       	ldi	r24, 0x00	; 0
 1ae:	28 96       	adiw	r28, 0x08	; 8
 1b0:	0f b6       	in	r0, 0x3f	; 63
 1b2:	f8 94       	cli
 1b4:	de bf       	out	0x3e, r29	; 62
 1b6:	0f be       	out	0x3f, r0	; 63
 1b8:	cd bf       	out	0x3d, r28	; 61
 1ba:	df 91       	pop	r29
 1bc:	cf 91       	pop	r28
 1be:	08 95       	ret

000001c0 <_Z19calibrate_gyroscopev>:
 1c0:	4f 92       	push	r4
 1c2:	5f 92       	push	r5
 1c4:	6f 92       	push	r6
 1c6:	7f 92       	push	r7
 1c8:	8f 92       	push	r8
 1ca:	9f 92       	push	r9
 1cc:	af 92       	push	r10
 1ce:	bf 92       	push	r11
 1d0:	cf 92       	push	r12
 1d2:	df 92       	push	r13
 1d4:	ef 92       	push	r14
 1d6:	ff 92       	push	r15
 1d8:	0f 93       	push	r16
 1da:	1f 93       	push	r17
 1dc:	cf 93       	push	r28
 1de:	df 93       	push	r29
 1e0:	cd b7       	in	r28, 0x3d	; 61
 1e2:	de b7       	in	r29, 0x3e	; 62
 1e4:	60 97       	sbiw	r28, 0x10	; 16
 1e6:	0f b6       	in	r0, 0x3f	; 63
 1e8:	f8 94       	cli
 1ea:	de bf       	out	0x3e, r29	; 62
 1ec:	0f be       	out	0x3f, r0	; 63
 1ee:	cd bf       	out	0x3d, r28	; 61
 1f0:	10 ed       	ldi	r17, 0xD0	; 208
 1f2:	19 83       	std	Y+1, r17	; 0x01
 1f4:	8b e1       	ldi	r24, 0x1B	; 27
 1f6:	8a 83       	std	Y+2, r24	; 0x02
 1f8:	80 e1       	ldi	r24, 0x10	; 16
 1fa:	8b 83       	std	Y+3, r24	; 0x03
 1fc:	63 e0       	ldi	r22, 0x03	; 3
 1fe:	ce 01       	movw	r24, r28
 200:	01 96       	adiw	r24, 0x01	; 1
 202:	0e 94 b4 01 	call	0x368	; 0x368 <TWI_Start_Transceiver_With_Data>
 206:	19 83       	std	Y+1, r17	; 0x01
 208:	83 e4       	ldi	r24, 0x43	; 67
 20a:	8a 83       	std	Y+2, r24	; 0x02
 20c:	81 ed       	ldi	r24, 0xD1	; 209
 20e:	8c 83       	std	Y+4, r24	; 0x04
 210:	00 e0       	ldi	r16, 0x00	; 0
 212:	14 e0       	ldi	r17, 0x04	; 4
 214:	62 e0       	ldi	r22, 0x02	; 2
 216:	ce 01       	movw	r24, r28
 218:	01 96       	adiw	r24, 0x01	; 1
 21a:	0e 94 b4 01 	call	0x368	; 0x368 <TWI_Start_Transceiver_With_Data>
 21e:	67 e0       	ldi	r22, 0x07	; 7
 220:	ce 01       	movw	r24, r28
 222:	04 96       	adiw	r24, 0x04	; 4
 224:	0e 94 b4 01 	call	0x368	; 0x368 <TWI_Start_Transceiver_With_Data>
 228:	67 e0       	ldi	r22, 0x07	; 7
 22a:	ce 01       	movw	r24, r28
 22c:	04 96       	adiw	r24, 0x04	; 4
 22e:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <TWI_Get_Data_From_Transceiver>
 232:	8d 81       	ldd	r24, Y+5	; 0x05
 234:	90 e0       	ldi	r25, 0x00	; 0
 236:	98 2f       	mov	r25, r24
 238:	88 27       	eor	r24, r24
 23a:	2e 81       	ldd	r18, Y+6	; 0x06
 23c:	82 2b       	or	r24, r18
 23e:	09 2e       	mov	r0, r25
 240:	00 0c       	add	r0, r0
 242:	aa 0b       	sbc	r26, r26
 244:	bb 0b       	sbc	r27, r27
 246:	48 0e       	add	r4, r24
 248:	59 1e       	adc	r5, r25
 24a:	6a 1e       	adc	r6, r26
 24c:	7b 1e       	adc	r7, r27
 24e:	8f 81       	ldd	r24, Y+7	; 0x07
 250:	90 e0       	ldi	r25, 0x00	; 0
 252:	98 2f       	mov	r25, r24
 254:	88 27       	eor	r24, r24
 256:	28 85       	ldd	r18, Y+8	; 0x08
 258:	82 2b       	or	r24, r18
 25a:	09 2e       	mov	r0, r25
 25c:	00 0c       	add	r0, r0
 25e:	aa 0b       	sbc	r26, r26
 260:	bb 0b       	sbc	r27, r27
 262:	88 0e       	add	r8, r24
 264:	99 1e       	adc	r9, r25
 266:	aa 1e       	adc	r10, r26
 268:	bb 1e       	adc	r11, r27
 26a:	89 85       	ldd	r24, Y+9	; 0x09
 26c:	90 e0       	ldi	r25, 0x00	; 0
 26e:	98 2f       	mov	r25, r24
 270:	88 27       	eor	r24, r24
 272:	2a 85       	ldd	r18, Y+10	; 0x0a
 274:	82 2b       	or	r24, r18
 276:	09 2e       	mov	r0, r25
 278:	00 0c       	add	r0, r0
 27a:	aa 0b       	sbc	r26, r26
 27c:	bb 0b       	sbc	r27, r27
 27e:	c8 0e       	add	r12, r24
 280:	d9 1e       	adc	r13, r25
 282:	ea 1e       	adc	r14, r26
 284:	fb 1e       	adc	r15, r27
 286:	89 ef       	ldi	r24, 0xF9	; 249
 288:	90 e0       	ldi	r25, 0x00	; 0
 28a:	01 97       	sbiw	r24, 0x01	; 1
 28c:	f1 f7       	brne	.-4      	; 0x28a <_Z19calibrate_gyroscopev+0xca>
 28e:	00 c0       	rjmp	.+0      	; 0x290 <_Z19calibrate_gyroscopev+0xd0>
 290:	00 00       	nop
 292:	01 50       	subi	r16, 0x01	; 1
 294:	11 09       	sbc	r17, r1
 296:	09 f0       	breq	.+2      	; 0x29a <_Z19calibrate_gyroscopev+0xda>
 298:	bd cf       	rjmp	.-134    	; 0x214 <_Z19calibrate_gyroscopev+0x54>
 29a:	d3 01       	movw	r26, r6
 29c:	c2 01       	movw	r24, r4
 29e:	77 20       	and	r7, r7
 2a0:	24 f4       	brge	.+8      	; 0x2aa <_Z19calibrate_gyroscopev+0xea>
 2a2:	81 50       	subi	r24, 0x01	; 1
 2a4:	9c 4f       	sbci	r25, 0xFC	; 252
 2a6:	af 4f       	sbci	r26, 0xFF	; 255
 2a8:	bf 4f       	sbci	r27, 0xFF	; 255
 2aa:	07 2e       	mov	r0, r23
 2ac:	7a e0       	ldi	r23, 0x0A	; 10
 2ae:	b5 95       	asr	r27
 2b0:	a7 95       	ror	r26
 2b2:	97 95       	ror	r25
 2b4:	87 95       	ror	r24
 2b6:	7a 95       	dec	r23
 2b8:	d1 f7       	brne	.-12     	; 0x2ae <_Z19calibrate_gyroscopev+0xee>
 2ba:	70 2d       	mov	r23, r0
 2bc:	9c 87       	std	Y+12, r25	; 0x0c
 2be:	8b 87       	std	Y+11, r24	; 0x0b
 2c0:	d5 01       	movw	r26, r10
 2c2:	c4 01       	movw	r24, r8
 2c4:	bb 20       	and	r11, r11
 2c6:	24 f4       	brge	.+8      	; 0x2d0 <_Z19calibrate_gyroscopev+0x110>
 2c8:	81 50       	subi	r24, 0x01	; 1
 2ca:	9c 4f       	sbci	r25, 0xFC	; 252
 2cc:	af 4f       	sbci	r26, 0xFF	; 255
 2ce:	bf 4f       	sbci	r27, 0xFF	; 255
 2d0:	07 2e       	mov	r0, r23
 2d2:	7a e0       	ldi	r23, 0x0A	; 10
 2d4:	b5 95       	asr	r27
 2d6:	a7 95       	ror	r26
 2d8:	97 95       	ror	r25
 2da:	87 95       	ror	r24
 2dc:	7a 95       	dec	r23
 2de:	d1 f7       	brne	.-12     	; 0x2d4 <_Z19calibrate_gyroscopev+0x114>
 2e0:	70 2d       	mov	r23, r0
 2e2:	9e 87       	std	Y+14, r25	; 0x0e
 2e4:	8d 87       	std	Y+13, r24	; 0x0d
 2e6:	d7 01       	movw	r26, r14
 2e8:	c6 01       	movw	r24, r12
 2ea:	ff 20       	and	r15, r15
 2ec:	24 f4       	brge	.+8      	; 0x2f6 <_Z19calibrate_gyroscopev+0x136>
 2ee:	81 50       	subi	r24, 0x01	; 1
 2f0:	9c 4f       	sbci	r25, 0xFC	; 252
 2f2:	af 4f       	sbci	r26, 0xFF	; 255
 2f4:	bf 4f       	sbci	r27, 0xFF	; 255
 2f6:	07 2e       	mov	r0, r23
 2f8:	7a e0       	ldi	r23, 0x0A	; 10
 2fa:	b5 95       	asr	r27
 2fc:	a7 95       	ror	r26
 2fe:	97 95       	ror	r25
 300:	87 95       	ror	r24
 302:	7a 95       	dec	r23
 304:	d1 f7       	brne	.-12     	; 0x2fa <_Z19calibrate_gyroscopev+0x13a>
 306:	70 2d       	mov	r23, r0
 308:	98 8b       	std	Y+16, r25	; 0x10
 30a:	8f 87       	std	Y+15, r24	; 0x0f
 30c:	ce 01       	movw	r24, r28
 30e:	0b 96       	adiw	r24, 0x0b	; 11
 310:	0e 94 a4 00 	call	0x148	; 0x148 <_Z13set_gyro_biasPi>
 314:	80 e0       	ldi	r24, 0x00	; 0
 316:	60 96       	adiw	r28, 0x10	; 16
 318:	0f b6       	in	r0, 0x3f	; 63
 31a:	f8 94       	cli
 31c:	de bf       	out	0x3e, r29	; 62
 31e:	0f be       	out	0x3f, r0	; 63
 320:	cd bf       	out	0x3d, r28	; 61
 322:	df 91       	pop	r29
 324:	cf 91       	pop	r28
 326:	1f 91       	pop	r17
 328:	0f 91       	pop	r16
 32a:	ff 90       	pop	r15
 32c:	ef 90       	pop	r14
 32e:	df 90       	pop	r13
 330:	cf 90       	pop	r12
 332:	bf 90       	pop	r11
 334:	af 90       	pop	r10
 336:	9f 90       	pop	r9
 338:	8f 90       	pop	r8
 33a:	7f 90       	pop	r7
 33c:	6f 90       	pop	r6
 33e:	5f 90       	pop	r5
 340:	4f 90       	pop	r4
 342:	08 95       	ret

00000344 <main>:
 344:	0e 94 aa 01 	call	0x354	; 0x354 <TWI_Master_Initialise>
 348:	0e 94 82 02 	call	0x504	; 0x504 <UART_initialise>
 34c:	78 94       	sei
 34e:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <_Z19calibrate_gyroscopev>
 352:	ff cf       	rjmp	.-2      	; 0x352 <main+0xe>

00000354 <TWI_Master_Initialise>:
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
  TWI_statusReg.all = 0;      
  TWI_state         = TWI_NO_STATE ;
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
 354:	82 e0       	ldi	r24, 0x02	; 2
 356:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
 35a:	8f ef       	ldi	r24, 0xFF	; 255
 35c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 360:	84 e0       	ldi	r24, 0x04	; 4
 362:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 366:	08 95       	ret

00000368 <TWI_Start_Transceiver_With_Data>:
 368:	cf 93       	push	r28
 36a:	df 93       	push	r29
 36c:	ec 01       	movw	r28, r24
 36e:	ec eb       	ldi	r30, 0xBC	; 188
 370:	f0 e0       	ldi	r31, 0x00	; 0
 372:	90 81       	ld	r25, Z
 374:	90 fd       	sbrc	r25, 0
 376:	fd cf       	rjmp	.-6      	; 0x372 <TWI_Start_Transceiver_With_Data+0xa>
 378:	60 93 06 01 	sts	0x0106, r22	; 0x800106 <TWI_msgSize>
 37c:	88 81       	ld	r24, Y
 37e:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <TWI_buf>
 382:	80 fd       	sbrc	r24, 0
 384:	13 c0       	rjmp	.+38     	; 0x3ac <TWI_Start_Transceiver_With_Data+0x44>
 386:	62 30       	cpi	r22, 0x02	; 2
 388:	88 f0       	brcs	.+34     	; 0x3ac <TWI_Start_Transceiver_With_Data+0x44>
 38a:	fe 01       	movw	r30, r28
 38c:	31 96       	adiw	r30, 0x01	; 1
 38e:	a8 e0       	ldi	r26, 0x08	; 8
 390:	b1 e0       	ldi	r27, 0x01	; 1
 392:	62 50       	subi	r22, 0x02	; 2
 394:	26 2f       	mov	r18, r22
 396:	30 e0       	ldi	r19, 0x00	; 0
 398:	2e 5f       	subi	r18, 0xFE	; 254
 39a:	3f 4f       	sbci	r19, 0xFF	; 255
 39c:	ce 01       	movw	r24, r28
 39e:	82 0f       	add	r24, r18
 3a0:	93 1f       	adc	r25, r19
 3a2:	21 91       	ld	r18, Z+
 3a4:	2d 93       	st	X+, r18
 3a6:	e8 17       	cp	r30, r24
 3a8:	f9 07       	cpc	r31, r25
 3aa:	d9 f7       	brne	.-10     	; 0x3a2 <TWI_Start_Transceiver_With_Data+0x3a>
 3ac:	10 92 05 01 	sts	0x0105, r1	; 0x800105 <TWI_statusReg>
 3b0:	88 ef       	ldi	r24, 0xF8	; 248
 3b2:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 3b6:	85 ea       	ldi	r24, 0xA5	; 165
 3b8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 3bc:	df 91       	pop	r29
 3be:	cf 91       	pop	r28
 3c0:	08 95       	ret

000003c2 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
 3c2:	ac 01       	movw	r20, r24
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
 3c4:	ec eb       	ldi	r30, 0xBC	; 188
 3c6:	f0 e0       	ldi	r31, 0x00	; 0
 3c8:	90 81       	ld	r25, Z
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 3ca:	90 fd       	sbrc	r25, 0
 3cc:	fd cf       	rjmp	.-6      	; 0x3c8 <TWI_Get_Data_From_Transceiver+0x6>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
 3ce:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <TWI_statusReg>
 3d2:	80 ff       	sbrs	r24, 0
 3d4:	12 c0       	rjmp	.+36     	; 0x3fa <TWI_Get_Data_From_Transceiver+0x38>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 3d6:	66 23       	and	r22, r22
 3d8:	81 f0       	breq	.+32     	; 0x3fa <TWI_Get_Data_From_Transceiver+0x38>
 3da:	a7 e0       	ldi	r26, 0x07	; 7
 3dc:	b1 e0       	ldi	r27, 0x01	; 1
 3de:	fa 01       	movw	r30, r20
 3e0:	61 50       	subi	r22, 0x01	; 1
 3e2:	26 2f       	mov	r18, r22
 3e4:	30 e0       	ldi	r19, 0x00	; 0
 3e6:	2f 5f       	subi	r18, 0xFF	; 255
 3e8:	3f 4f       	sbci	r19, 0xFF	; 255
 3ea:	ca 01       	movw	r24, r20
 3ec:	82 0f       	add	r24, r18
 3ee:	93 1f       	adc	r25, r19
    {
      msg[ i ] = TWI_buf[ i ];
 3f0:	2d 91       	ld	r18, X+
 3f2:	21 93       	st	Z+, r18

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 3f4:	e8 17       	cp	r30, r24
 3f6:	f9 07       	cpc	r31, r25
 3f8:	d9 f7       	brne	.-10     	; 0x3f0 <TWI_Get_Data_From_Transceiver+0x2e>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
 3fa:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <TWI_statusReg>
}
 3fe:	81 70       	andi	r24, 0x01	; 1
 400:	08 95       	ret

00000402 <__vector_24>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
 402:	1f 92       	push	r1
 404:	0f 92       	push	r0
 406:	0f b6       	in	r0, 0x3f	; 63
 408:	0f 92       	push	r0
 40a:	11 24       	eor	r1, r1
 40c:	2f 93       	push	r18
 40e:	3f 93       	push	r19
 410:	8f 93       	push	r24
 412:	9f 93       	push	r25
 414:	af 93       	push	r26
 416:	bf 93       	push	r27
 418:	ef 93       	push	r30
 41a:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
 41c:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
 420:	8e 2f       	mov	r24, r30
 422:	90 e0       	ldi	r25, 0x00	; 0
 424:	fc 01       	movw	r30, r24
 426:	38 97       	sbiw	r30, 0x08	; 8
 428:	e1 35       	cpi	r30, 0x51	; 81
 42a:	f1 05       	cpc	r31, r1
 42c:	08 f0       	brcs	.+2      	; 0x430 <__vector_24+0x2e>
 42e:	56 c0       	rjmp	.+172    	; 0x4dc <__vector_24+0xda>
 430:	ec 5c       	subi	r30, 0xCC	; 204
 432:	ff 4f       	sbci	r31, 0xFF	; 255
 434:	0c 94 91 03 	jmp	0x722	; 0x722 <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
 438:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <__data_end>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
 43c:	e0 91 04 01 	lds	r30, 0x0104	; 0x800104 <__data_end>
 440:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <TWI_msgSize>
 444:	e8 17       	cp	r30, r24
 446:	70 f4       	brcc	.+28     	; 0x464 <__vector_24+0x62>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
 448:	81 e0       	ldi	r24, 0x01	; 1
 44a:	8e 0f       	add	r24, r30
 44c:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <__data_end>
 450:	f0 e0       	ldi	r31, 0x00	; 0
 452:	e9 5f       	subi	r30, 0xF9	; 249
 454:	fe 4f       	sbci	r31, 0xFE	; 254
 456:	80 81       	ld	r24, Z
 458:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 45c:	85 e8       	ldi	r24, 0x85	; 133
 45e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 462:	43 c0       	rjmp	.+134    	; 0x4ea <__vector_24+0xe8>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 464:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <TWI_statusReg>
 468:	81 60       	ori	r24, 0x01	; 1
 46a:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 46e:	84 e9       	ldi	r24, 0x94	; 148
 470:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 474:	3a c0       	rjmp	.+116    	; 0x4ea <__vector_24+0xe8>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
 476:	e0 91 04 01 	lds	r30, 0x0104	; 0x800104 <__data_end>
 47a:	81 e0       	ldi	r24, 0x01	; 1
 47c:	8e 0f       	add	r24, r30
 47e:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <__data_end>
 482:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 486:	f0 e0       	ldi	r31, 0x00	; 0
 488:	e9 5f       	subi	r30, 0xF9	; 249
 48a:	fe 4f       	sbci	r31, 0xFE	; 254
 48c:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
 48e:	20 91 04 01 	lds	r18, 0x0104	; 0x800104 <__data_end>
 492:	30 e0       	ldi	r19, 0x00	; 0
 494:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <TWI_msgSize>
 498:	90 e0       	ldi	r25, 0x00	; 0
 49a:	01 97       	sbiw	r24, 0x01	; 1
 49c:	28 17       	cp	r18, r24
 49e:	39 07       	cpc	r19, r25
 4a0:	24 f4       	brge	.+8      	; 0x4aa <__vector_24+0xa8>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 4a2:	85 ec       	ldi	r24, 0xC5	; 197
 4a4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 4a8:	20 c0       	rjmp	.+64     	; 0x4ea <__vector_24+0xe8>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 4aa:	85 e8       	ldi	r24, 0x85	; 133
 4ac:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 4b0:	1c c0       	rjmp	.+56     	; 0x4ea <__vector_24+0xe8>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
 4b2:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 4b6:	e0 91 04 01 	lds	r30, 0x0104	; 0x800104 <__data_end>
 4ba:	f0 e0       	ldi	r31, 0x00	; 0
 4bc:	e9 5f       	subi	r30, 0xF9	; 249
 4be:	fe 4f       	sbci	r31, 0xFE	; 254
 4c0:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 4c2:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <TWI_statusReg>
 4c6:	81 60       	ori	r24, 0x01	; 1
 4c8:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 4cc:	84 e9       	ldi	r24, 0x94	; 148
 4ce:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
 4d2:	0b c0       	rjmp	.+22     	; 0x4ea <__vector_24+0xe8>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 4d4:	85 ea       	ldi	r24, 0xA5	; 165
 4d6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
 4da:	07 c0       	rjmp	.+14     	; 0x4ea <__vector_24+0xe8>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
 4dc:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
 4e0:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
 4e4:	84 e0       	ldi	r24, 0x04	; 4
 4e6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
 4ea:	ff 91       	pop	r31
 4ec:	ef 91       	pop	r30
 4ee:	bf 91       	pop	r27
 4f0:	af 91       	pop	r26
 4f2:	9f 91       	pop	r25
 4f4:	8f 91       	pop	r24
 4f6:	3f 91       	pop	r19
 4f8:	2f 91       	pop	r18
 4fa:	0f 90       	pop	r0
 4fc:	0f be       	out	0x3f, r0	; 63
 4fe:	0f 90       	pop	r0
 500:	1f 90       	pop	r1
 502:	18 95       	reti

00000504 <UART_initialise>:
			return 1;
		}
		return 0;
	}
	return 0;	
}
 504:	80 ec       	ldi	r24, 0xC0	; 192
 506:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 50a:	86 e0       	ldi	r24, 0x06	; 6
 50c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 510:	8c e0       	ldi	r24, 0x0C	; 12
 512:	90 e0       	ldi	r25, 0x00	; 0
 514:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
 518:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
 51c:	08 95       	ret

0000051e <__vector_18>:

ISR(USART_RX_vect){
 51e:	1f 92       	push	r1
 520:	0f 92       	push	r0
 522:	0f b6       	in	r0, 0x3f	; 63
 524:	0f 92       	push	r0
 526:	11 24       	eor	r1, r1
 528:	2f 93       	push	r18
 52a:	3f 93       	push	r19
 52c:	4f 93       	push	r20
 52e:	5f 93       	push	r21
 530:	6f 93       	push	r22
 532:	7f 93       	push	r23
 534:	8f 93       	push	r24
 536:	9f 93       	push	r25
 538:	af 93       	push	r26
 53a:	bf 93       	push	r27
 53c:	cf 93       	push	r28
 53e:	df 93       	push	r29
 540:	ef 93       	push	r30
 542:	ff 93       	push	r31
	rx_buffer[rx_cnt] = UDR0;
 544:	c0 91 18 01 	lds	r28, 0x0118	; 0x800118 <rx_buffer>
 548:	d0 91 19 01 	lds	r29, 0x0119	; 0x800119 <rx_buffer+0x1>
 54c:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <rx_cnt>
 550:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <rx_cnt+0x1>
 554:	a0 91 11 01 	lds	r26, 0x0111	; 0x800111 <rx_cnt+0x2>
 558:	b0 91 12 01 	lds	r27, 0x0112	; 0x800112 <rx_cnt+0x3>
 55c:	20 91 c6 00 	lds	r18, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 560:	fe 01       	movw	r30, r28
 562:	e8 0f       	add	r30, r24
 564:	f9 1f       	adc	r31, r25
 566:	20 83       	st	Z, r18
	if(rx_cnt > 0)
 568:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <rx_cnt>
 56c:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <rx_cnt+0x1>
 570:	a0 91 11 01 	lds	r26, 0x0111	; 0x800111 <rx_cnt+0x2>
 574:	b0 91 12 01 	lds	r27, 0x0112	; 0x800112 <rx_cnt+0x3>
 578:	89 2b       	or	r24, r25
 57a:	8a 2b       	or	r24, r26
 57c:	8b 2b       	or	r24, r27
 57e:	61 f1       	breq	.+88     	; 0x5d8 <__vector_18+0xba>
		if(memcmp(&rx_buffer[rx_cnt-1], rx_terminator, 2)){
 580:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <rx_cnt>
 584:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <rx_cnt+0x1>
 588:	a0 91 11 01 	lds	r26, 0x0111	; 0x800111 <rx_cnt+0x2>
 58c:	b0 91 12 01 	lds	r27, 0x0112	; 0x800112 <rx_cnt+0x3>
 590:	01 97       	sbiw	r24, 0x01	; 1
 592:	42 e0       	ldi	r20, 0x02	; 2
 594:	50 e0       	ldi	r21, 0x00	; 0
 596:	61 e0       	ldi	r22, 0x01	; 1
 598:	71 e0       	ldi	r23, 0x01	; 1
 59a:	8c 0f       	add	r24, r28
 59c:	9d 1f       	adc	r25, r29
 59e:	0e 94 97 03 	call	0x72e	; 0x72e <memcmp>
 5a2:	89 2b       	or	r24, r25
 5a4:	c9 f0       	breq	.+50     	; 0x5d8 <__vector_18+0xba>
			// In this case, we just append \0 and disable the UART reception, then set correct state
			rx_buffer[rx_cnt + 1] = '\0';
 5a6:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <rx_cnt>
 5aa:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <rx_cnt+0x1>
 5ae:	a0 91 11 01 	lds	r26, 0x0111	; 0x800111 <rx_cnt+0x2>
 5b2:	b0 91 12 01 	lds	r27, 0x0112	; 0x800112 <rx_cnt+0x3>
 5b6:	c8 0f       	add	r28, r24
 5b8:	d9 1f       	adc	r29, r25
 5ba:	19 82       	std	Y+1, r1	; 0x01
			if(state == tx_rx)
 5bc:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <state>
 5c0:	83 30       	cpi	r24, 0x03	; 3
 5c2:	21 f4       	brne	.+8      	; 0x5cc <__vector_18+0xae>
				state = tx;
 5c4:	81 e0       	ldi	r24, 0x01	; 1
 5c6:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <state>
 5ca:	02 c0       	rjmp	.+4      	; 0x5d0 <__vector_18+0xb2>
			else
				state = waiting;
 5cc:	10 92 17 01 	sts	0x0117, r1	; 0x800117 <state>
			UART_rx_disable();
 5d0:	e1 ec       	ldi	r30, 0xC1	; 193
 5d2:	f0 e0       	ldi	r31, 0x00	; 0
 5d4:	80 81       	ld	r24, Z
 5d6:	10 82       	st	Z, r1
		}
	++rx_cnt;
 5d8:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <rx_cnt>
 5dc:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <rx_cnt+0x1>
 5e0:	a0 91 11 01 	lds	r26, 0x0111	; 0x800111 <rx_cnt+0x2>
 5e4:	b0 91 12 01 	lds	r27, 0x0112	; 0x800112 <rx_cnt+0x3>
 5e8:	01 96       	adiw	r24, 0x01	; 1
 5ea:	a1 1d       	adc	r26, r1
 5ec:	b1 1d       	adc	r27, r1
 5ee:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <rx_cnt>
 5f2:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <rx_cnt+0x1>
 5f6:	a0 93 11 01 	sts	0x0111, r26	; 0x800111 <rx_cnt+0x2>
 5fa:	b0 93 12 01 	sts	0x0112, r27	; 0x800112 <rx_cnt+0x3>
}
 5fe:	ff 91       	pop	r31
 600:	ef 91       	pop	r30
 602:	df 91       	pop	r29
 604:	cf 91       	pop	r28
 606:	bf 91       	pop	r27
 608:	af 91       	pop	r26
 60a:	9f 91       	pop	r25
 60c:	8f 91       	pop	r24
 60e:	7f 91       	pop	r23
 610:	6f 91       	pop	r22
 612:	5f 91       	pop	r21
 614:	4f 91       	pop	r20
 616:	3f 91       	pop	r19
 618:	2f 91       	pop	r18
 61a:	0f 90       	pop	r0
 61c:	0f be       	out	0x3f, r0	; 63
 61e:	0f 90       	pop	r0
 620:	1f 90       	pop	r1
 622:	18 95       	reti

00000624 <__vector_19>:

ISR(USART_UDRE_vect){
 624:	1f 92       	push	r1
 626:	0f 92       	push	r0
 628:	0f b6       	in	r0, 0x3f	; 63
 62a:	0f 92       	push	r0
 62c:	11 24       	eor	r1, r1
 62e:	2f 93       	push	r18
 630:	3f 93       	push	r19
 632:	4f 93       	push	r20
 634:	5f 93       	push	r21
 636:	6f 93       	push	r22
 638:	7f 93       	push	r23
 63a:	8f 93       	push	r24
 63c:	9f 93       	push	r25
 63e:	af 93       	push	r26
 640:	bf 93       	push	r27
 642:	ef 93       	push	r30
 644:	ff 93       	push	r31
	++tx_cnt;// increment txCnt (since the byte has been loaded in transmitter
 646:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <tx_cnt>
 64a:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <tx_cnt+0x1>
 64e:	a0 91 15 01 	lds	r26, 0x0115	; 0x800115 <tx_cnt+0x2>
 652:	b0 91 16 01 	lds	r27, 0x0116	; 0x800116 <tx_cnt+0x3>
 656:	01 96       	adiw	r24, 0x01	; 1
 658:	a1 1d       	adc	r26, r1
 65a:	b1 1d       	adc	r27, r1
 65c:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <tx_cnt>
 660:	90 93 14 01 	sts	0x0114, r25	; 0x800114 <tx_cnt+0x1>
 664:	a0 93 15 01 	sts	0x0115, r26	; 0x800115 <tx_cnt+0x2>
 668:	b0 93 16 01 	sts	0x0116, r27	; 0x800116 <tx_cnt+0x3>
	if(tx_cnt < tx_length){
 66c:	40 91 13 01 	lds	r20, 0x0113	; 0x800113 <tx_cnt>
 670:	50 91 14 01 	lds	r21, 0x0114	; 0x800114 <tx_cnt+0x1>
 674:	60 91 15 01 	lds	r22, 0x0115	; 0x800115 <tx_cnt+0x2>
 678:	70 91 16 01 	lds	r23, 0x0116	; 0x800116 <tx_cnt+0x3>
 67c:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <tx_length>
 680:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <tx_length+0x1>
 684:	a0 91 1e 01 	lds	r26, 0x011E	; 0x80011e <tx_length+0x2>
 688:	b0 91 1f 01 	lds	r27, 0x011F	; 0x80011f <tx_length+0x3>
 68c:	48 17       	cp	r20, r24
 68e:	59 07       	cpc	r21, r25
 690:	6a 07       	cpc	r22, r26
 692:	7b 07       	cpc	r23, r27
 694:	98 f4       	brcc	.+38     	; 0x6bc <__vector_19+0x98>
		UDR0 = tx_buffer[tx_cnt];
 696:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <tx_cnt>
 69a:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <tx_cnt+0x1>
 69e:	a0 91 15 01 	lds	r26, 0x0115	; 0x800115 <tx_cnt+0x2>
 6a2:	b0 91 16 01 	lds	r27, 0x0116	; 0x800116 <tx_cnt+0x3>
 6a6:	20 91 1a 01 	lds	r18, 0x011A	; 0x80011a <tx_buffer>
 6aa:	30 91 1b 01 	lds	r19, 0x011B	; 0x80011b <tx_buffer+0x1>
 6ae:	f9 01       	movw	r30, r18
 6b0:	e8 0f       	add	r30, r24
 6b2:	f9 1f       	adc	r31, r25
 6b4:	80 81       	ld	r24, Z
 6b6:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 6ba:	04 c0       	rjmp	.+8      	; 0x6c4 <__vector_19+0xa0>
		//this clears the interrupt flag automatically.
	}
	else{
		//disable UDRE interrupt
		UCSR0B &= !(1<<UDRIE0);
 6bc:	e1 ec       	ldi	r30, 0xC1	; 193
 6be:	f0 e0       	ldi	r31, 0x00	; 0
 6c0:	80 81       	ld	r24, Z
 6c2:	10 82       	st	Z, r1
		//once last byte has left, TX_vect should trigger, updating the transmit state
	}
}
 6c4:	ff 91       	pop	r31
 6c6:	ef 91       	pop	r30
 6c8:	bf 91       	pop	r27
 6ca:	af 91       	pop	r26
 6cc:	9f 91       	pop	r25
 6ce:	8f 91       	pop	r24
 6d0:	7f 91       	pop	r23
 6d2:	6f 91       	pop	r22
 6d4:	5f 91       	pop	r21
 6d6:	4f 91       	pop	r20
 6d8:	3f 91       	pop	r19
 6da:	2f 91       	pop	r18
 6dc:	0f 90       	pop	r0
 6de:	0f be       	out	0x3f, r0	; 63
 6e0:	0f 90       	pop	r0
 6e2:	1f 90       	pop	r1
 6e4:	18 95       	reti

000006e6 <__vector_20>:

ISR(USART_TX_vect){
 6e6:	1f 92       	push	r1
 6e8:	0f 92       	push	r0
 6ea:	0f b6       	in	r0, 0x3f	; 63
 6ec:	0f 92       	push	r0
 6ee:	11 24       	eor	r1, r1
 6f0:	8f 93       	push	r24
 6f2:	ef 93       	push	r30
 6f4:	ff 93       	push	r31
	// set state to only rx of coming from tx_rx
	// alternatively, when coming from tx, go back to waiting.
	if(state == tx_rx)
 6f6:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <state>
 6fa:	83 30       	cpi	r24, 0x03	; 3
 6fc:	21 f4       	brne	.+8      	; 0x706 <__vector_20+0x20>
		state = rx;
 6fe:	82 e0       	ldi	r24, 0x02	; 2
 700:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <state>
 704:	02 c0       	rjmp	.+4      	; 0x70a <__vector_20+0x24>
	else
		state = waiting;
 706:	10 92 17 01 	sts	0x0117, r1	; 0x800117 <state>
	UART_tx_disable();
 70a:	e1 ec       	ldi	r30, 0xC1	; 193
 70c:	f0 e0       	ldi	r31, 0x00	; 0
 70e:	80 81       	ld	r24, Z
 710:	10 82       	st	Z, r1
}
 712:	ff 91       	pop	r31
 714:	ef 91       	pop	r30
 716:	8f 91       	pop	r24
 718:	0f 90       	pop	r0
 71a:	0f be       	out	0x3f, r0	; 63
 71c:	0f 90       	pop	r0
 71e:	1f 90       	pop	r1
 720:	18 95       	reti

00000722 <__tablejump2__>:
 722:	ee 0f       	add	r30, r30
 724:	ff 1f       	adc	r31, r31
 726:	05 90       	lpm	r0, Z+
 728:	f4 91       	lpm	r31, Z
 72a:	e0 2d       	mov	r30, r0
 72c:	09 94       	ijmp

0000072e <memcmp>:
 72e:	fb 01       	movw	r30, r22
 730:	dc 01       	movw	r26, r24
 732:	04 c0       	rjmp	.+8      	; 0x73c <memcmp+0xe>
 734:	8d 91       	ld	r24, X+
 736:	01 90       	ld	r0, Z+
 738:	80 19       	sub	r24, r0
 73a:	21 f4       	brne	.+8      	; 0x744 <memcmp+0x16>
 73c:	41 50       	subi	r20, 0x01	; 1
 73e:	50 40       	sbci	r21, 0x00	; 0
 740:	c8 f7       	brcc	.-14     	; 0x734 <memcmp+0x6>
 742:	88 1b       	sub	r24, r24
 744:	99 0b       	sbc	r25, r25
 746:	08 95       	ret

00000748 <_exit>:
 748:	f8 94       	cli

0000074a <__stop_program>:
 74a:	ff cf       	rjmp	.-2      	; 0x74a <__stop_program>
